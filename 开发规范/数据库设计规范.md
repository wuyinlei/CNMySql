# 数据库设计规范

标签（空格分隔）： Java后台 课余学习

---

## 数据库命名规范
* 所有数据库对象名称必须使用小写字母并用下划线分隔
* 所有数据库对象名称禁止使用MySql保留关键字
* 数据库对象的命名要能做到见文知意,并且最好不要超过32个字符
* 临时表必须以tmp为前缀并以日期为后缀(不强制)
* 备份表,备份表必须以bak为前缀并且以日期为后缀(不强制)
* 所有存储相同数据的列明和列类型必须一致

## 数据库基本设计规范
* 所有表必须使用Innodb存储引擎
    * 支持事物、行级锁、更好的恢复性、高并发下性能更好
* 数据库和表的字符集统一使用UTF8(避免乱码)
* 所有表和字段都需要添加注释
    * 使用comment从句添加表和列的备注
    * 从一开始就进行数据字典的维护
* 尽量控制单表的数据量的大小,建议控制在500W以内
    * 500w并不是MySql数据库的限制
    * 可以用历史数据归档,分库分表等手段来限制
* 谨慎使用MySql分区表
    * 分区表在物理上表现为多个文件,在逻辑上表现为一个
    * 谨慎选择分区键,跨分区查询效率可能更低
* 尽量做到冷热数据分离,减少表的宽度
    * 减少磁盘IO,保证热数据的内存缓存命中率
    * 利用更有效的利用缓存
    * 避免读入无用的冷数据
    * 经常一起使用的列放到一个表中
* 禁止在表中建立预留字段
    * 预留字段的命名很难做到见文知意
    * 无法确认存储的数据类型,所以无法选择合适的类型
    * 对预留字段类型的修改,会对表进行锁定
* 禁止在数据库中存储图片、文件等二进制数据
* 禁止在线上数据库做压力测试
* 禁止从开发环境、测试环境直接连接生成环境
        
## 数据库索引设计规范
索引对数据的查询性能是非常重要的(双刃剑)

* 限制每张表上的索引数量,建议单张表索引不超过5个
    * 索引不是越多越好,索引可以提高也可以降低查询效率
    * 禁止给表中的每一列都建立单独的索引
    * Innodb是按照哪个索引的顺序来组织表的呢？
        * 主键 
* 每个Innodb表必须有一个主键
* 不使用更新频繁的列作为主键,不是用多列主键
* 不使用UUID、MD5、HASH字符串作为主键
* 主键建议使用自增ID值
* 如何选择索引列的顺序
    * 区分度最高的列放在联合索引的最左侧
    * 尽量把字段长度小的列放到联合索引的最左侧
* 避免建立冗余索引和重复索引
* 对于频繁的查询优先考虑使用覆盖索引
    * 覆盖索引:包含了所有查询字段的索引
    * 避免Innodb表进行索引的二次查找
    * 可以把随机IO变为顺序IO加快查询效率
* 尽量避免使用外键
    * 外键可用于保证数据的参照完整性,但建议在业务端实现
    * 外键会影响父表和子表的写操作从而降低性能
                
## 数据库字段设计规范
字段类型的选择,会直接影响数据库的性能

* 优先选择符合存储需要的最小的数据类型
* 对于非负型的数据来说,要优先使用无符号整形来存储
    * 无符号相对于有符号可以多出一倍的存储空间
    * VARCHAR(N)中的N代表的是字符串,而不是字节数
    * 使用UTF8存储汉字Varchar(255)=756个字节
    * 过大的长度会消耗更多的内存
* 避免使用TEXT、BLOG数据类型
    * 建议把BLOG或者TEXT列分离到单独的扩展表中
    * TEXT或者BLOG类型只能使用前缀索引
* 避免使用ENUM数据类型
    * 使用ENUM值需要使用ALTER语句
    * ENUM类型的ORDER BY操作效率低,需要额外操作
    * 禁止使用数值作为ENUM的枚举值
* 尽可能的把所有列定义为NOT NULL(非空)
    * 索引NULL列需要额外的空间来保存,需要占用更多的空间
    * 进行比较和计算的时候要对NULL值做特别的处理
* 字符串存储日期类型的数据(不正确的做法)
    * 无法用日期函数进行计算和比较
    * 用字符串存储日期需要占用更多的存储空间
    * 使用TIMESTAMP或者DATETIME类型存储时间
        * TIMESTAMP : 1970-01-01 00:00:01 ~  2038-01-19 03:14:07
        * TIMESTAMP占用4字节和INT相同,但是比INT可读性高
    * 超出TIMESTAMP取值范围的使用DATETIME类型
* 同财务相关的金额类数据,必须使用decimal类型
    * decimal类型为精准浮点数,在计算的时候不会丢失精确度
    * 占用空间由定义的宽度决定
    * 可用于存储比bigint更大的整数数据
            
## SQL开发规范

* 建议使用预编译语句进行数据库操作
    * 只传参数,比传递SQL语句更加高效
* 避免数据类型的隐式转换
    * 隐式转换会导致索引失效
* 合理利用存在索引,而不是盲目增加索引
    * 避免使用双%号的查询条件 如a like ‘%123%’
    * 一个SQL只能利用到复合索引中的一列进行范围查询
    * 使用left join或者not exists来优化not in操作
* 程序连接不同的数据库使用不同的账号,禁止跨库查询
    * 为数据库迁移和分库分表留出余地
    * 降低业务耦合度
    * 避免权限过大而产生的安全风险
    * 禁止使用SELECT * 必须使用SELECT <字段列表>查询
        * 消耗更多的CPU和IO以及网络带宽资源
        * 无法使用覆盖索引
        * 可以减少表结构变更带来的影响
* 禁止使用不含字段列表的INSERT语句
* 禁止使用子查询,可以把子查询优化为join操作
    * 子查询的结果集无法使用索引
    * 子查询会产生临时表操作,如果子查询数据量大则严重影响效率
    * 消耗过多的CPU及IO资源
* 避免使用JOIN关联太多的表
    * 每一个表会占用一部分内存(join_buffer_size)
    * 会产生临时表操作,影响查询效率
    * MySql最多允许关联61个表,建议不超过5个
* 减少同数据库的交互次数
    * 数据库更合适处理批量操作
    * 合并多个相同的操作到一起,可以提高处理效率
* 使用in代替or
    * in的值不要超过500个
    * in操作可以有效的使用索引
* 禁止使用order by rand()进行随机排序
    * 会把表中所有符合条件的数据装在到内存中进行排序
    * 会消耗大量的CPU和IO及内存资源
    * 推荐在程序中获取一个随机值,然后从数据库中获取数据的方式
* WHERE从句中禁止对列进行函数转换和计算
    * 对列进行函数转换或者计算会导致无法使用索引
        * 例如不使用where date(createtime) = '20170809'
        * 而是使用where createtime >= '20170809' and createtime <= '20170810'
* 在明显不会有重复值的时候使用UNIQUE ALL而不是UNION
    * UNION会把所有数据放到临时表中后在进行去重操作 
    * UNIQUE ALL不会再对结果集进行去重操作
* 拆分复杂的大SQL为多个小SQL语句进行查询
    * MySql中一个Sql只能使用到一个CPU进行计算
    * Sqlchai'fen
                                                             
## 数据库操作规范
* 超过100w行的批量写操作,要分批多次进行操作
    * 大批量的操作可能会造成严重的主从延迟
    * binlog日志为row格式时候会产生大量的日志
    * 避免产生大事务操作
* 对大数据结构的修改一定要谨慎,会造成严重的锁表操作,尤其是生产环境
* 对于大表使用pt-online-schema-change修改表结构
    * 避免大表修改产生的主从延迟
    * 避免在对表字段进行修改时候进行锁表
* 禁止为程序使用的账号赋予super权限
    * super账号只能留给DBA处理问题的账号使用
* 对于程序连接数据库账号,遵循权限最小原则
    * 程序使用数据库账号只能在一个DB下使用,不准跨库使用
    * 程序使用的账号原则上不准有drop权限
            


